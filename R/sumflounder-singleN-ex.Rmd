---
title: "sim-sumflounder"
author: "Angelia Miller"
date: "2023-06-27"
output: html_document
---

# Objective 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(raster)
library(SimSurvey)
suppressPackageStartupMessages(library(tidyverse))
library(data.table)
library(patchwork)
library(here)


sdmtmb.dir <- "../sseep-analysis/sdmtmb"
sseep.analysis <- "../sseep-analysis"
```


_Stock Assessment Data_
Recruitment at age 0 and fishing mortality data are pulled from the Summer Flounder Management Track Assessment for 2021 (Table 1). The natural mortality value and Von Bertalanffy growth parameters are pulled from the 66th Stock Assessment Workshop report (2019).
```{r}
set.seed(8675309)

# Recruitment at age 0 for the most recent year, 2019; numbers were reported in thousands in the MTA report.
Rec_age0 <- 48689*1000 
#mean(Rec_age0)
#sd(Rec_age0)

# fishing mortality for the most recent year, 2019
F <- 0.340 

# natural mortality
M <- 0.2

#total mortality
Z <- F + M
#mean(Z)
#sd(Z)
#log(sd(Z))

# Von Bertalanffy growth parameters for both male and female
Linf = 83.6
K = 0.14

```

_Survey Grid_
```{r}
grid <- readRDS(file = here(sdmtmb.dir, "data", "survey_grid.rds")) |>
   rename(strat = STRATUM,
          depth = AVGDEPTH) |>
   mutate(division = 1,
          x = X/1000,
          y = Y/1000) |>
   dplyr::select(x, y, cell, division, strat, depth) |>
   as.data.frame()

crs <-  "+proj=utm +zone=18 +datum=WGS84 +units=km +no_defs"

grid_ras <- rasterFromXYZ(grid, crs = crs)


ggplot(grid) + geom_tile(aes(x, y), width = 10, height = 10)

```



_Spatial Distribution Predictions_ 
Historical summer flounder biomass catch rate data was used to fit a spatiotemporal GLMM with the sdmTMB package. The expected biomass catch rates predicted from the model fit was extracted for the most recent 5 years of the time series.  
```{r}
# load spring model predictions
spring_preds <- readRDS(file = here(sdmtmb.dir, "data", "spring_projects.rds"))

# filter distribution predictions for last 5 years
preds_3yr <- spring_preds |>
  filter(EST_YEAR %in% c(2019:2021)) |>
  rename(year = EST_YEAR, 
         strat = STRATUM) |>
   mutate(N_dist = exp(est), 
          year = case_when(
    year == 2019 ~ 1, 
    year == 2020 ~ 2, 
    year == 2021 ~ 3
  ),
         cell = seq(1:length(N_dist))) |>
  dplyr::select(X,Y, year, N_dist, cell, strat) |>
  data.table::as.data.table()

ggplot(preds_3yr) + 
  geom_tile(aes(X, Y, fill = N_dist), width = 10, height = 10) +
  scale_fill_viridis_c() + 
  facet_wrap(~year) + 
  labs(x = "Longitude", y = "Latitude", fill = "Number of Summer Flounder") + 
  theme_bw() + 
  theme(legend.position = "bottom")

```


# Simulate Abundance 
```{r}
pop1 <- sim_abundance(ages = 0:7, years = 1:3,
                     R = sim_R(log_mean = log(mean(Rec_age0)), log_sd = 0.001, plot = TRUE),
                     Z = sim_Z(log_mean = log(mean(Z)), log_sd = 0.001, plot = TRUE),
                     growth = sim_vonB(Linf = 83.6, K = 0.14, plot = TRUE)) 
Nage1 <- tibble(age = 0:7, pop1$N0)
plot_surface(pop1, mat = "N")

#saveRDS(pop, here("data", "rds", "sumflounder_abundance.rds"))
```


# Append the simulated abundance 
```{r}
# append  to abundance and rename list item
pop1 <- append(pop1, grid_ras) # use RasterStack object of sdmtmb grid
names(pop1)[[10]] <- "grid"

# resave dataframe grid to match dummy data grid
grid_xy <- grid |>
 # dplyr::select(X, Y, depth, division, strat) |>
  #rename(x = X, y = Y) |>
  data.table::as.data.table()
  #mutate(cell = seq(1:length(depth)))

# append to the simulated abundance object
pop1 <- append(pop1, list(grid_xy))

names(pop1)[[11]] <- "grid_xy"

# calculate numbers at age in each cell based on the year distribution
dist1 <- sdmTMB::replicate_df(preds_3yr, "age", c(0:7)) |>
  left_join(Nage1, by = "age") |>
  rename(Nage = "pop1$N0",
         x = X,
         y = Y) |>
  mutate(P_i = N_dist/sum(N_dist), # probability of distribution
         N = Nage * P_i, # multiply probability by simulated numbers of age
         age = as.double(age),
         cell = as.double(cell)) |>
  dplyr::select(age, year, cell, N, x, y, strat)



# append to the simulated abundance object
pop1 <- append(pop1, list(dist1))
names(pop1)[[12]] <- "sp_N"

#saveRDS(pop1, here("data", "rds", "sumflounder_dist.rds"))

# plot numbers at age
ggplot(pop1$sp_N) + 
  geom_tile(aes(x, y, fill = N), width = 10, height = 10) +
  scale_fill_viridis_c(trans = "sqrt") + 
  facet_wrap(~age, scales = "free_y") + 
  labs(x = "Longitude", y = "Latitude", fill = "Number of Summer Flounder") + 
  theme_bw() + 
  theme(legend.position = "bottom")

```

# Simulate Survey
```{r}

surv_dat1 <- pop1 |>
  sim_survey(n_sims = 2,
             trawl_dim = c(1.5, 0.014),
             q = sim_logistic(k = 2, x0 = 2.5), #if plot = TRUE, xlim errors
             set_den = 0.0025,
             resample_cells = TRUE)

#saveRDS(surv_dat3, here("data", "rds", "sumflounder_survdat.rds"))

```

# Performance Measures

## Relative abundance over time
```{r}
# read in the area weights for each strata 
strata_wts <- readRDS(here(sseep.analysis, "data", "rds", "active_strata_wts.rds")) |>
  rename(strat = STRATUM)

# find the total survey area 
BTSArea <- as.integer(sum(strata_wts$Area_SqNm))
```

### True Abundance 
Output from sim_abundance and sim_distribution
```{r}
# subset data based on sim_distribution output
true_N <- surv_dat1$sp_N |> as_tibble() |>
  full_join(grid_xy, by = c("cell", "strat", "x", "y"))

# calculate the individual mean abundance in each strata for each year and simulation
trueN_ind <- true_N |>
    group_by(strat, year) |>
    dplyr::summarise(towct = length(N), # calculate unique tows
                     mu = sum(N, na.rm = TRUE)/towct, # find the average biomass based on unique tows rather than observations to avoid potential duplication
                     var = ifelse(towct == 1, 0, # if the tow count equals 1, then variance about the mean should be 0
                                  sum((N - mu)^2, na.rm = TRUE)/(towct - 1)), 
                     .groups = "keep") # if tow count does not equal 1, then find the variance of biomass

# caluclate the weighted average by multiplying by each stratas proportional area
trueN_wtd <- trueN_ind |>
    left_join(strata_wts, by = "strat") |> # add each stratum area and relative weight to the dataset based on STRATUM number
      group_by(strat, year) |>
    mutate(wt_mu = Area_SqNm * mu, # part one of the stratified mean formula
           wt_var = ((((RelWt)^2) * var) / towct) * (1 - (towct / Area_SqNm)), 
           wt_var = ifelse(is.na(wt_var), 0, wt_var)) 
           # part one of the stratified variance formula

# calculated the stratified average and the standard deviations around the average 
trueN_strat <- trueN_wtd |>
    group_by(year) |>
    summarise(stratmu = (sum(wt_mu)) / BTSArea, # part two of the stratified mean formula
              stratvar = sum(wt_var), .groups = "keep") |>
  mutate(sdlog = sqrt(log(1+(sqrt(stratvar)/stratmu)^2)), #logistic standard deviation
         lower = qlnorm(0.025, log(stratmu), sdlog), # lower quantile of the logistic normal distribution
         upper = qlnorm(0.975, log(stratmu), sdlog)) |> # upper quantile of the logistic normal distribution
  mutate(sdlog = ifelse(is.nan(sdlog), 0, sdlog), # if sdlog is NaN, replace with 0
         lower = ifelse(is.nan(lower), 0, lower), # if the lower quantile is NaN, replace with 0
         upper = ifelse(is.nan(upper), 0, upper), 
         TYPE = "True",
         sim = 1) |>
  na.omit()

```


```{r}
# create a plot of the indices of abundance from the observed data 
trueN_plot <- ggplot() +
  geom_pointrange(data = trueN_strat, 
                  aes(x = as.factor(year), y = stratmu, ymin=lower, ymax = upper), 
                  position = position_dodge2(width=0.4)) +
  #facet_wrap(vars(SEASON), scales = "free_y") +
  #facet_grid(rows = vars(GEO_AREA), cols = vars(SEASON), scales = "free_y") + 
  labs(x = "YEAR", y = "Stratified Mean (N/tow)", color = "Season", title = "Observed Abundance Index") +
  #ylim(0,NA) +
  theme_bw()

trueN_plot

```

### Estimated Abundance
Bias - variance
precision - CV = sd/mu

```{r}
# pull out the simulated numbers of summer flounder from the survey
est_N <- surv_dat1$setdet |> as_tibble()

# check individual strata information
# x <- setdet |>
#     filter(strat==1010, year==1, sim==1)

# calculate the individual mean abundance in each strata for each year and simulation
estN_ind <- est_N |>
    group_by(strat, year, sim) |>
    dplyr::summarise(towct = length(set), # calculate unique tows
              mu = sum(N)/towct, # find the average biomass based on unique tows rather than observations to avoid potential duplication
              var = ifelse(towct == 1, 0, # if the tow count equals 1, then variance about the mean should be 0
                           sum((N - mu)^2)/(towct - 1)), .groups = "keep") # if tow count does not equal 1, then find the variance of biomass

# caluclate the weighted average by multiplying by each stratas proportional area
estN_wtd <- estN_ind |>
    left_join(strata_wts, by = "strat") |> # add each stratum area and relative weight to the dataset based on STRATUM number
      group_by(strat, year, sim) |>
    mutate(wt_mu = Area_SqNm * mu, # part one of the stratified mean formula
           wt_var = ((((RelWt)^2) * var) / towct) * (1 - (towct / Area_SqNm)), 
           wt_var = ifelse(is.na(wt_var), 0, wt_var)) 
           # part one of the stratified variance formula

# calculated the stratified average and the standard deviations around the average 
estN_strat <- estN_wtd |>
    group_by(year, sim) |>
    summarise(stratmu = (sum(wt_mu)) / BTSArea, # part two of the stratified mean formula
              stratvar = sum(wt_var), .groups = "keep") |>
  mutate(sdlog = sqrt(log(1+(sqrt(stratvar)/stratmu)^2)), #logistic standard deviation
         lower = qlnorm(0.025, log(stratmu), sdlog), # lower quantile of the logistic normal distribution
         upper = qlnorm(0.975, log(stratmu), sdlog)) |> # upper quantile of the logistic normal distribution
  mutate(sdlog = ifelse(is.nan(sdlog), 0, sdlog), # if sdlog is NaN, replace with 0
         lower = ifelse(is.nan(lower), 0, lower), # if the lower quantile is NaN, replace with 0
         upper = ifelse(is.nan(upper), 0, upper), 
         TYPE = "Estimated")

```


Plot of estimated abundance indices over time for each simulation
```{r}
# create a plot of the indices of abundance from the simulated data 
estN_plot <- ggplot() +
  #geom_point() +
  geom_pointrange(data = estN_strat, aes(x = as.factor(year), y = stratmu, color = as.factor(sim), ymin=lower, ymax = upper), position = position_dodge2(width=0.4)) +
  #facet_wrap(vars(SEASON), scales = "free_y") +
  #facet_grid(rows = vars(GEO_AREA), cols = vars(SEASON), scales = "free_y") + 
  labs(x = "YEAR", y = "Stratified Mean (N/tow)", color = "Simulation", 
       title = "Simulated Abundance Index") +
  #ylim(0,NA) +
  theme_bw() #+ 

estN_plot
```

### Compare plots
```{r}

compareN_AI <- bind_rows(trueN_strat, estN_strat)  
  
compareN_plot <- ggplot() +
  #geom_point() +
  geom_pointrange(data = compareN_AI, aes(x = as.factor(year), y = stratmu, color = as.factor(sim), shape = TYPE, ymin=lower, ymax = upper), position = position_dodge2(width=0.4)) +
  #facet_wrap(vars(SEASON), scales = "free_y") +
  #facet_grid(rows = vars(GEO_AREA), cols = vars(SEASON), scales = "free_y") + 
  labs(x = "YEAR", y = "Stratified Mean (N/tow)", color = "Simulation", 
       title = "Simulated Abundance Index") +
  #ylim(0,NA) +
  theme_bw() 

compareN_plot

# plot the two plots side by side 
estN_plot + trueN_plot & theme(legend.position = "bottom")


```
### Precision
 - "the precision of the mean density estimate of species g
at time t across replicate surveys and is the standard deviation of the simulated survey estimates (where rgt is the mean density estimate of species g at time t averaged across the D surveys) relative to ygt , the true mean density of species g at time t" (Oyafuso et al 2021)
 - "The True CV (TrueCVst) is the variability of the estimated abundance index across the survey replicates and is defined as the standard deviation of the estimated indices of abundance normalized by the true value" (Oyafuso et al 2023)
```{r}
trueN_stratmu <- mean(trueN_strat$stratmu)

estN_strat |>
  group_by(sim, year) |> 
  summarise(cv = sqrt(stratvar) / trueN_stratmu)


```


## Change in relative abundance over time
Bias & precision 
### True Abundance 
```{r}
trueN_mod <- lm(stratmu~year, data = trueN_strat) |>
  broom::tidy(conf.int = TRUE) |> 
  mutate(TYPE = "True") |> 
  filter(term == "year")

trueN_mod

```

### Estimated Abundance 
```{r}
estN_mod <- estN_strat |>
  group_by(sim) |>
  nest() |> 
  mutate(model = map(data, ~lm(stratmu~year, data =.)), 
         coef = map(model, broom::tidy, conf.int = TRUE)) |>
  unnest(coef) |> 
  mutate(TYPE = str_c("Simulation", sim, sep = " ")) |>
  filter(term == "year") |>
  select(!c(data, model))

estN_mod

```

### Slope Comparison
```{r}
Nslopes <- bind_rows(trueN_mod, estN_mod)

Nslopes

ggplot(Nslopes) + 
  geom_pointrange(aes(x = as.factor(TYPE), y = estimate, color = TYPE, ymin=conf.low, ymax = conf.high), position = position_dodge2(width=0.4)) +
  #facet_wrap(vars(SEASON), scales = "free_y") +
  #facet_grid(rows = vars(GEO_AREA), cols = vars(SEASON), scales = "free_y") + 
  labs(x = "Type", y = "Linear Regression Slope Estimates ", color = " ", 
       title = "Changes in Abundance Indices over time") +
  #ylim(0,NA) +
  theme_bw() 
```


## Average sampling error of catch rate

Something with strat_sets or cell_sets? 
```{r}
# estCR_n <- length(!is.na(setdet$N)) # n = 727
# 
# estCR_se <- est_N |> 
#   group_by(year, sim) |> 
#   summarise(stratsd = sqrt(stratvar), 
#             samp_err = 1.96*(stratsd / sqrt(estL_n)))
# 
# estL_se |> 
#   group_by(sim) |>
#   summarise(avg_se = mean(samp_err))

```


## Mean length
- Bias & precision in mean length

```{r, include=FALSE}
### True Length
```

### Estimated Length 
```{r}
#extract data and merge together to obtain lengths in taken in a given strata
setdet <- surv_dat1$setdet |> as_tibble()
samp <- surv_dat1$samp |> as_tibble()
data <- full_join(setdet, samp, by = "set") 
```

```{r}
estL_ind <- data |>
    group_by(strat, year, sim) |>
    dplyr::summarise(towct = length(set), # calculate unique tows
              mu = sum(length, na.rm = TRUE)/towct, # find the average biomass based on unique tows rather than observations to avoid potential duplication
              var = ifelse(towct == 1, 0, # if the tow count equals 1, then variance about the mean should be 0
                           sum((length - mu)^2, na.rm = TRUE)/(towct - 1)), 
              .groups = "keep") # if tow count does not equal 1, then find the variance of biomass

# caluclate the weighted average by multiplying by each stratas proportional area
estL_wtd <- estL_ind |>
    left_join(strata_wts, by = "strat") |> # add each stratum area and relative weight to the dataset based on STRATUM number
      group_by(strat, year, sim) |>
    mutate(wt_mu = Area_SqNm * mu, # part one of the stratified mean formula
           wt_var = ((((RelWt)^2) * var) / towct) * (1 - (towct / Area_SqNm)), 
           wt_var = ifelse(is.na(wt_var), 0, wt_var)) 
           # part one of the stratified variance formula

# calculated the stratified average and the standard deviations around the average 
estL_strat <- estL_wtd  |>
    group_by(year, sim) |>
    summarise(stratmu = (sum(wt_mu)) / BTSArea, # part two of the stratified mean formula
              stratvar = sum(wt_var), .groups = "keep") |>
  mutate(sdlog = sqrt(log(1+(sqrt(stratvar)/stratmu)^2)), #logistic standard deviation
         lower = qlnorm(0.025, log(stratmu), sdlog), # lower quantile of the logistic normal distribution
         upper = qlnorm(0.975, log(stratmu), sdlog)) |> # upper quantile of the logistic normal distribution
  mutate(sdlog = ifelse(is.nan(sdlog), 0, sdlog), # if sdlog is NaN, replace with 0
         lower = ifelse(is.nan(lower), 0, lower), # if the lower quantile is NaN, replace with 0
         upper = ifelse(is.nan(upper), 0, upper))

estL_strat

```

```{r}
ggplot() +
  geom_pointrange(data = estL_strat, aes(x = as.factor(year), y = stratmu, color = as.factor(sim), ymin=lower, ymax = upper), position = position_dodge2(width=0.4)) +
  labs(x = "Year", y = "Stratified Length", color = "Simulation", 
       title = "Stratified Mean Length") +
  #ylim(0,NA) +
  theme_bw() 
```


### Average sampling error for mean length
```{r}
estL_n <- length(samp$length)

estL_se <- estL_strat |> 
  group_by(year, sim) |> 
  summarise(stratsd = sqrt(stratvar), 
            samp_err = 1.96*(stratsd / sqrt(estL_n)))

estL_se |> 
  group_by(sim) |>
  summarise(avg_se = mean(samp_err))

```


### Adequacy of coverage of length distribution
```{r}
ggplot() +
  geom_histogram(data = samp, aes(x = length)) +
  theme_bw() 
```



## Mean Age
- Bias & precision in mean age
### True Age 
### Estimated Age 
- Average sampling error for mean age
- Adequacy of coverage of age distribution


## Relative abundance of smoll fish
- Bias & precision in relative abundance of smoll fish over time
- Bias & precision in change in relative abundance of smoll fish over time
- Average sampling error for mean catch rate of smoll fish
